# Extremely redundant secret storer

If you need to securely store a small file extremely redundantly e.g. a BIP
passphrase file like one generated by https://bip39.onekey.so/ (do NOT use
an online generator of crypto wallet keys!), where:

1. 'Securely' = at least a few years for a nation state actor to brute force
the encryption.

2. 'Extremely redundantly' = many copies in both digital and printed forms
stored in ways resistant to bitrot and fire.

3. Where any Apple or Linux device can be used to recover that small file
from either the digital or printed form.

Then these scripts you might find useful.

Firstly you need to create a Python venv for your system using:

```
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

And for obvious reasons, do this from an internet connected
environment, transferring the venv produced into a secure
not internet connected environment afterwards!


To encode a small file, use `./encode_file.py <file>`. It will take
your passphrase and estimate how secure it is. If that security is
acceptable, reenter the same password twice for the `age` file
encryption tool to encrypt your small file. The encrypted file is
then:

1. Has sixty-four redundant parity based copies made of it via the
venerable `par2` program. This should be highly resistant to bit
flips on a storage device as only any one of the sixty-four copies
needs to survive. Even if the filesystem gets corrupted, it should
be possible to retrieve at least some of the file content.

2. A printable QR code is generated with 15% redundancy i.e. up
to 15% of the image can be destroyed and the file can be
reconstituted. As QR codes can store a maximum of a kilobyte after
encryption and base64 encoding, you need to ensure that the input
file is small enough to not overflow the maximum QR code size. You
should print many copies of this QR code and store them in multiple
secure locations.

To make sure that both forms definitely parse back into the original,
the encoding script will call the decoding script and check that
both the parity based form and the QR based form both decode into
the original small file. For this you will need the `zbarimg`
utility installed -- any Linux or Mac system's package manager
will have that utility.


To retrieve the small file, use `./decode_file.py <file>.age`.
This will firstly check the parity files against the encrypted
file, and repair any damage found. It will then invoke `age` to
decrypt the file, which will require the original passphrase.
The output from `age` is never stored in a temporary file, but
is output to `stdout`.

Precompiled standalone binaries for `par2` and `age` for:

1. Linux x64
2. Linux aarch64
3. Mac OS aarch64

... are included. They should work on any system as-is without
any dependencies requiring installed.

If you need to retrieve the small file from a picture of a
QR code, you will need to install a QR code image parsing
utility which will almost certainly be one of:

1. `zbarimg`
2. `zxing` which comes in both Java and C++ editions.

To be absolutely secure, I would recommend that the QR code
decoding stage be performed outside a secure environment
where either of those tools can be installed, as they have
complex dependencies requiring an internet connection. That will
yield a base64 encoded string such as:

```
YWdlLWVuY3J5cHRpb24ub3JnL3YxCi0+IHNjcnlwdCBBVjc3RkFEdGg1Y2hudkoy <continues ...>
```

If you then feed that to `base64 -d` you will get back the original `age`
encrypted file e.g.

```
zbarimg -q --raw 0xb3142e11aDA222ca7F646B090843fE4d0f19409E.txt.age.png | base64 -d
age-encryption.org/v1
-> scrypt AV77FADth5chnvJ2MZ1txg <binary data follows ...>
```

You should take that `age` encrypted file to a secure environment
where there is no possibility of output capture and then decrypt it using
`age -d`.

You can have the script do all of the above for you using 
`./decode_file.py --output <file>.age --qrcode <file>.age.<img>`.
This will invoke `zbarimg` on the image file (it can be any image format
which `zbarimg` supports) to extract the base64 encoded files, base64
decodes it, and saves it into the output file. This only converts the
QR code image to the .age file and stops there.

If you don't care so much about security, `./decode_file.py --qrcode-and-decrypt <file>.age.<img>`
will do the same but then feed it into `age` for you. It does
not use a temporary file when doing this, and it defaults to
outputting the decrypted file to `stdout` which may or may not
be desirable.

## What is a secure environment?

You shouldn't trust anything I say. But I would say that most of
those whom I trust think that a sub-user account on [GrapheneOS](https://grapheneos.org/)
is probably fairly secure so long as you install absolutely
no apps into that sub-user account. GrapheneOS has a not well
advertised feature which lets you install a Linux subsystem into
a sub-user account. Within that, you can run these scripts,
and you're probably fairly safe that nobody will be recording
what you type or what gets printed to the screen.

If GrapheneOS is too much effort for you, [ChromeOS Flex](https://chromeos.google/products/chromeos-flex/)
lets you turn any spare PC hardware into a Chromebook. I'm
personally far less sure that Google doesn't capture everything
you type or show on the screen especially now that they put AIs
into just about everything, but ChromeOS does have the advantage
of having an immutable sysroot like recent Mac OS. That means
it won't boot if anybody has modified the system root, and
that's enormously better than most Linux or Windows installations.

Finally, a **completely clean** Apple Mac device is probably
also reasonably secure, again due to the immutable sysroot.
You do need to never install anything, nor browse the web, nor
do anything which could compromise the cleanliness of that clean
device. I put it after ChromeOS because the default Mac OS install
has far too many apps pre-installed.

There are almost certainly other immutable sysroot based platforms
which might also suffice. Just DO NOT EVER EVER use a Microsoft
Windows installation of ANY kind, nor a traditional Linux installation
of ANY kind. Anything with a mutable sysroot is not a secure
environment BY DEFINITION.
